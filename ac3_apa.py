# -*- coding: utf-8 -*-
"""AC3-APA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a5Mwj3aJ9ekk2xAbyrePfW4rQll637eq
"""

import math
import itertools

#gerador de coordenadas aleatórias
def criaCoord(n): 
  from random import randint

  coord_cid = {}
  for i in range(1,n+1):
    coord = []
    coord.append(randint(1,n))
    coord.append(randint(1,n))
    while True:
        if not (coord[0], coord[1]) in coord_cid.values():
          coord_cid[i] = coord
          break
  return coord_cid

# calcula distância entre pontos
def calculaDistancia(local1, local2):
    """
    Este metodo calcula a distancia entre dois pontos
    """
    #delta na coordenada x
    dx = local1[0] - local2[0]
    #delta na coordenada y
    dy = local1[1] - local2[1]
    #distancia
    distancia = math.sqrt(dx ** 2 + dy ** 2)
    return distancia

# Parâmetros do problema


# Matriz de custos
def criaMatrizCustos(cidades):
  mat_custos = []
  listaCoord = criaCoord(cidades)
  for i in range(1,len(listaCoord)+1):
    linhaCusto = []
    for j in range(1,len(listaCoord)+1):
      linhaCusto.append(calculaDistancia(listaCoord[i], listaCoord[j]))
    mat_custos.append(linhaCusto)
  return mat_custos

# Commented out IPython magic to ensure Python compatibility.
qtd_pontos = int(input("Digite a quantidade de cidades que o caixeiro irá percorrer: "))
origem = int(input("Digite o valor onde o caixeiro irá iniciar: "))
destino= int(input("Digite o valor da cidade onde o caixeiro que terminar: "))
mat_custos = criaMatrizCustos(qtd_pontos)
custos = custoEntreCidades(mat_custos,qtd_pontos)
# %time caminhoDeValorMenor(qtd_pontos,custos,origem,destino)

qtd_pontos = 4
origem = int(input("Digite o valor onde o caixeiro irá iniciar: "))
destino= int(input("Digite o valor da cidade onde o caixeiro que terminar: "))

mat_custos = criaMatrizCustos(qtd_pontos)
custos = custoEntreCidades(mat_custos,qtd_pontos)
for caminhos in imprimecaminhos(qtd_pontos,custos):
  print(caminhos)
print("melhor caminho possivel "+str(caminhoDeValorMenor(qtd_pontos,custos,origem,destino)))

def custoEntreCidades(mat_custos,qtd_pontos):
  # Índices dos pontos de origem e destino
  origens = [i + 1 for i in range(qtd_pontos)]
  destinos = [i + 1 for i in range(qtd_pontos)]

  ##############################################
  #seta uma origem e destino
  # Dicionário dos custos
  custos = dict()
  for i, origem in enumerate(origens):
      for j, destino in enumerate(destinos):
          custos[origem, destino] = mat_custos[i][j]
nt(input("Digite a quantidade de cidades que o caixeiro irá percorrer: "))
  return custos

def caminhoDeValorMenor(qtd_pontos,custos, origem, destino):
  caminhos = []
  cidades =[]

  #cria uma lista de cidades baseadas no total de pontos
  for i in range(1,qtd_pontos+1):
    cidades.append(i)


  #criar caminhos possiveis (permutações)
  for p in itertools.permutations(cidades):
    caminhos.append(p)valormenor = 0
  indice = 0
  for i in range(lprint(en(caminhosencontrados)):for caminhos in imprimecaminhos(qtd_pontos,custos):
  print(caminhos)
print("melhor caminho possivel "+)
    if(i==0):
      valormenor=custocam[caminhosencontrados[i]]
      indice = i

    elif(valormenor > custocam[caminhosencontrados[i]]):
      valormenor = custocam[caminhosencontrados[i]]
      indice= i
  
  return valormenor,caminhosencontrados[i]



  #identificar o valor de custo de cada caminho
  custocam={}  
  for c in caminhos:
    valorcusto = 0
    for i in range (len(c)-1):
      valorcusto =valorcusto+ custos[c[i], c[i+1]]
    custocam[c]=valorcusto
  



#identifica os caminhos que tem a mesma origem e destino
valormenor = 0
  indice = 0valormenor = 0
  indice = 0
  for i in range(len(caminhosencontrados)):

    if(i==0):valormenor = 0
  indice = 0
  for i in range(len(caminhosencontrados)):
    if(i==0):
      valormenor=custocam[caminhosencontrados[i]]
      indice = i

    elif(valormenor > custocam[caminhosencontrados[i]]):


      valormenor = custocam[caminhosencontrados[i]]
      indice= i
  
  return valormenor,caminhosencontrados[i]

      valormenor=custocam[caminhosencontrados[i]]
      indice = i

    elif(valormenor > custocam[caminhosencontrados[i]]):
      valormenor = custocam[caminhosencontrados[i]]
      indice= i
  
  return valormenor,caminhosencontrados[i]

  for i in range(len(caminhosencontrados)):
    if(i==0):
      valormenor=custocam[caminhosencontrados[i]]
      indice = i

    elif(valormenor > custocam[caminhosencontrados[i]]):
      valormenor = custocam[caminhosencontrados[i]]
      indice= i
  
  return valormenor,caminhosencontrados[i]

  caminhosencontrados=[]
  for caminho in caminhos:
    if(caminho[0]==origem and caminho[len(caminho)-1]==destino):
      caminhosencontrados.append(caminho)


  #comparar o valor menor de cada caminho de mesma origem e destino
  valormenor = 0
  indice = 0
  for i in range(len(caminhosencontrados)):
    if(i==0):
      valormenor=custocam[caminhosencontrados[i]]
      indice = i

    elif(valormenor > custocam[caminhosencontrados[i]]):
      valormenor = custocam[caminhosencontrados[i]]
      indice= i
  
  return valormenor,caminhosencontrados[i]

def imprimecaminhos(qtd_pontos,custos):
  caminhos = []
  cidades =[]

  #cria uma lista de cidades baseadas no total de pontos
  for i in range(1,qtd_pontos+1):
    cidades.append(i)

  #criar caminhos possiveis (permutações)
  for p in itertools.permutations(cidades):
    caminhos.append(p)

  #identificar o valor de custo de cada caminho
  custocam={}  
  for c in caminhos:
    valorcusto = 0
    for i in range (len(c)-1):
      valorcusto =valorcusto+ custos[c[i], c[i+1]]
    custocam[c]=valorcusto

  return caminhos, valorcusto